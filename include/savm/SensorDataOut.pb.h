// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: SensorDataOut.proto

#ifndef PROTOBUF_SensorDataOut_2eproto__INCLUDED
#define PROTOBUF_SensorDataOut_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_SensorDataOut_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[2];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsSensorDataOut_vec2Impl();
void InitDefaultsSensorDataOut_vec2();
void InitDefaultsSensorDataOutImpl();
void InitDefaultsSensorDataOut();
inline void InitDefaults() {
  InitDefaultsSensorDataOut_vec2();
  InitDefaultsSensorDataOut();
}
}  // namespace protobuf_SensorDataOut_2eproto
namespace protobuf {
class SensorDataOut;
class SensorDataOutDefaultTypeInternal;
extern SensorDataOutDefaultTypeInternal _SensorDataOut_default_instance_;
class SensorDataOut_vec2;
class SensorDataOut_vec2DefaultTypeInternal;
extern SensorDataOut_vec2DefaultTypeInternal _SensorDataOut_vec2_default_instance_;
}  // namespace protobuf
namespace protobuf {

// ===================================================================

class SensorDataOut_vec2 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protobuf.SensorDataOut.vec2) */ {
 public:
  SensorDataOut_vec2();
  virtual ~SensorDataOut_vec2();

  SensorDataOut_vec2(const SensorDataOut_vec2& from);

  inline SensorDataOut_vec2& operator=(const SensorDataOut_vec2& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SensorDataOut_vec2(SensorDataOut_vec2&& from) noexcept
    : SensorDataOut_vec2() {
    *this = ::std::move(from);
  }

  inline SensorDataOut_vec2& operator=(SensorDataOut_vec2&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SensorDataOut_vec2& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SensorDataOut_vec2* internal_default_instance() {
    return reinterpret_cast<const SensorDataOut_vec2*>(
               &_SensorDataOut_vec2_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(SensorDataOut_vec2* other);
  friend void swap(SensorDataOut_vec2& a, SensorDataOut_vec2& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SensorDataOut_vec2* New() const PROTOBUF_FINAL { return New(NULL); }

  SensorDataOut_vec2* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SensorDataOut_vec2& from);
  void MergeFrom(const SensorDataOut_vec2& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SensorDataOut_vec2* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // float y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // @@protoc_insertion_point(class_scope:protobuf.SensorDataOut.vec2)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float x_;
  float y_;
  mutable int _cached_size_;
  friend struct ::protobuf_SensorDataOut_2eproto::TableStruct;
  friend void ::protobuf_SensorDataOut_2eproto::InitDefaultsSensorDataOut_vec2Impl();
};
// -------------------------------------------------------------------

class SensorDataOut : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protobuf.SensorDataOut) */ {
 public:
  SensorDataOut();
  virtual ~SensorDataOut();

  SensorDataOut(const SensorDataOut& from);

  inline SensorDataOut& operator=(const SensorDataOut& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SensorDataOut(SensorDataOut&& from) noexcept
    : SensorDataOut() {
    *this = ::std::move(from);
  }

  inline SensorDataOut& operator=(SensorDataOut&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SensorDataOut& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SensorDataOut* internal_default_instance() {
    return reinterpret_cast<const SensorDataOut*>(
               &_SensorDataOut_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(SensorDataOut* other);
  friend void swap(SensorDataOut& a, SensorDataOut& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SensorDataOut* New() const PROTOBUF_FINAL { return New(NULL); }

  SensorDataOut* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SensorDataOut& from);
  void MergeFrom(const SensorDataOut& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SensorDataOut* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef SensorDataOut_vec2 vec2;

  // accessors -------------------------------------------------------

  // .protobuf.SensorDataOut.vec2 leadPos = 3;
  bool has_leadpos() const;
  void clear_leadpos();
  static const int kLeadPosFieldNumber = 3;
  const ::protobuf::SensorDataOut_vec2& leadpos() const;
  ::protobuf::SensorDataOut_vec2* release_leadpos();
  ::protobuf::SensorDataOut_vec2* mutable_leadpos();
  void set_allocated_leadpos(::protobuf::SensorDataOut_vec2* leadpos);

  // .protobuf.SensorDataOut.vec2 ownPos = 4;
  bool has_ownpos() const;
  void clear_ownpos();
  static const int kOwnPosFieldNumber = 4;
  const ::protobuf::SensorDataOut_vec2& ownpos() const;
  ::protobuf::SensorDataOut_vec2* release_ownpos();
  ::protobuf::SensorDataOut_vec2* mutable_ownpos();
  void set_allocated_ownpos(::protobuf::SensorDataOut_vec2* ownpos);

  // .protobuf.SensorDataOut.vec2 cornerFrontRight = 5;
  bool has_cornerfrontright() const;
  void clear_cornerfrontright();
  static const int kCornerFrontRightFieldNumber = 5;
  const ::protobuf::SensorDataOut_vec2& cornerfrontright() const;
  ::protobuf::SensorDataOut_vec2* release_cornerfrontright();
  ::protobuf::SensorDataOut_vec2* mutable_cornerfrontright();
  void set_allocated_cornerfrontright(::protobuf::SensorDataOut_vec2* cornerfrontright);

  // .protobuf.SensorDataOut.vec2 cornerFrontLeft = 6;
  bool has_cornerfrontleft() const;
  void clear_cornerfrontleft();
  static const int kCornerFrontLeftFieldNumber = 6;
  const ::protobuf::SensorDataOut_vec2& cornerfrontleft() const;
  ::protobuf::SensorDataOut_vec2* release_cornerfrontleft();
  ::protobuf::SensorDataOut_vec2* mutable_cornerfrontleft();
  void set_allocated_cornerfrontleft(::protobuf::SensorDataOut_vec2* cornerfrontleft);

  // .protobuf.SensorDataOut.vec2 cornerRearRight = 7;
  bool has_cornerrearright() const;
  void clear_cornerrearright();
  static const int kCornerRearRightFieldNumber = 7;
  const ::protobuf::SensorDataOut_vec2& cornerrearright() const;
  ::protobuf::SensorDataOut_vec2* release_cornerrearright();
  ::protobuf::SensorDataOut_vec2* mutable_cornerrearright();
  void set_allocated_cornerrearright(::protobuf::SensorDataOut_vec2* cornerrearright);

  // .protobuf.SensorDataOut.vec2 cornerRearLeft = 8;
  bool has_cornerrearleft() const;
  void clear_cornerrearleft();
  static const int kCornerRearLeftFieldNumber = 8;
  const ::protobuf::SensorDataOut_vec2& cornerrearleft() const;
  ::protobuf::SensorDataOut_vec2* release_cornerrearleft();
  ::protobuf::SensorDataOut_vec2* mutable_cornerrearleft();
  void set_allocated_cornerrearleft(::protobuf::SensorDataOut_vec2* cornerrearleft);

  // bool isPositionTracked = 1;
  void clear_ispositiontracked();
  static const int kIsPositionTrackedFieldNumber = 1;
  bool ispositiontracked() const;
  void set_ispositiontracked(bool value);

  // bool isSpeedTracked = 2;
  void clear_isspeedtracked();
  static const int kIsSpeedTrackedFieldNumber = 2;
  bool isspeedtracked() const;
  void set_isspeedtracked(bool value);

  // float leadSpeed = 9;
  void clear_leadspeed();
  static const int kLeadSpeedFieldNumber = 9;
  float leadspeed() const;
  void set_leadspeed(float value);

  // float ownSpeed = 10;
  void clear_ownspeed();
  static const int kOwnSpeedFieldNumber = 10;
  float ownspeed() const;
  void set_ownspeed(float value);

  // int32 curGear = 11;
  void clear_curgear();
  static const int kCurGearFieldNumber = 11;
  ::google::protobuf::int32 curgear() const;
  void set_curgear(::google::protobuf::int32 value);

  // float steerLock = 12;
  void clear_steerlock();
  static const int kSteerLockFieldNumber = 12;
  float steerlock() const;
  void set_steerlock(float value);

  // float enginerpm = 13;
  void clear_enginerpm();
  static const int kEnginerpmFieldNumber = 13;
  float enginerpm() const;
  void set_enginerpm(float value);

  // float enginerpmMax = 14;
  void clear_enginerpmmax();
  static const int kEnginerpmMaxFieldNumber = 14;
  float enginerpmmax() const;
  void set_enginerpmmax(float value);

  // float steer = 15;
  void clear_steer();
  static const int kSteerFieldNumber = 15;
  float steer() const;
  void set_steer(float value);

  // @@protoc_insertion_point(class_scope:protobuf.SensorDataOut)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::protobuf::SensorDataOut_vec2* leadpos_;
  ::protobuf::SensorDataOut_vec2* ownpos_;
  ::protobuf::SensorDataOut_vec2* cornerfrontright_;
  ::protobuf::SensorDataOut_vec2* cornerfrontleft_;
  ::protobuf::SensorDataOut_vec2* cornerrearright_;
  ::protobuf::SensorDataOut_vec2* cornerrearleft_;
  bool ispositiontracked_;
  bool isspeedtracked_;
  float leadspeed_;
  float ownspeed_;
  ::google::protobuf::int32 curgear_;
  float steerlock_;
  float enginerpm_;
  float enginerpmmax_;
  float steer_;
  mutable int _cached_size_;
  friend struct ::protobuf_SensorDataOut_2eproto::TableStruct;
  friend void ::protobuf_SensorDataOut_2eproto::InitDefaultsSensorDataOutImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SensorDataOut_vec2

// float x = 1;
inline void SensorDataOut_vec2::clear_x() {
  x_ = 0;
}
inline float SensorDataOut_vec2::x() const {
  // @@protoc_insertion_point(field_get:protobuf.SensorDataOut.vec2.x)
  return x_;
}
inline void SensorDataOut_vec2::set_x(float value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:protobuf.SensorDataOut.vec2.x)
}

// float y = 2;
inline void SensorDataOut_vec2::clear_y() {
  y_ = 0;
}
inline float SensorDataOut_vec2::y() const {
  // @@protoc_insertion_point(field_get:protobuf.SensorDataOut.vec2.y)
  return y_;
}
inline void SensorDataOut_vec2::set_y(float value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:protobuf.SensorDataOut.vec2.y)
}

// -------------------------------------------------------------------

// SensorDataOut

// bool isPositionTracked = 1;
inline void SensorDataOut::clear_ispositiontracked() {
  ispositiontracked_ = false;
}
inline bool SensorDataOut::ispositiontracked() const {
  // @@protoc_insertion_point(field_get:protobuf.SensorDataOut.isPositionTracked)
  return ispositiontracked_;
}
inline void SensorDataOut::set_ispositiontracked(bool value) {
  
  ispositiontracked_ = value;
  // @@protoc_insertion_point(field_set:protobuf.SensorDataOut.isPositionTracked)
}

// bool isSpeedTracked = 2;
inline void SensorDataOut::clear_isspeedtracked() {
  isspeedtracked_ = false;
}
inline bool SensorDataOut::isspeedtracked() const {
  // @@protoc_insertion_point(field_get:protobuf.SensorDataOut.isSpeedTracked)
  return isspeedtracked_;
}
inline void SensorDataOut::set_isspeedtracked(bool value) {
  
  isspeedtracked_ = value;
  // @@protoc_insertion_point(field_set:protobuf.SensorDataOut.isSpeedTracked)
}

// .protobuf.SensorDataOut.vec2 leadPos = 3;
inline bool SensorDataOut::has_leadpos() const {
  return this != internal_default_instance() && leadpos_ != NULL;
}
inline void SensorDataOut::clear_leadpos() {
  if (GetArenaNoVirtual() == NULL && leadpos_ != NULL) {
    delete leadpos_;
  }
  leadpos_ = NULL;
}
inline const ::protobuf::SensorDataOut_vec2& SensorDataOut::leadpos() const {
  const ::protobuf::SensorDataOut_vec2* p = leadpos_;
  // @@protoc_insertion_point(field_get:protobuf.SensorDataOut.leadPos)
  return p != NULL ? *p : *reinterpret_cast<const ::protobuf::SensorDataOut_vec2*>(
      &::protobuf::_SensorDataOut_vec2_default_instance_);
}
inline ::protobuf::SensorDataOut_vec2* SensorDataOut::release_leadpos() {
  // @@protoc_insertion_point(field_release:protobuf.SensorDataOut.leadPos)
  
  ::protobuf::SensorDataOut_vec2* temp = leadpos_;
  leadpos_ = NULL;
  return temp;
}
inline ::protobuf::SensorDataOut_vec2* SensorDataOut::mutable_leadpos() {
  
  if (leadpos_ == NULL) {
    leadpos_ = new ::protobuf::SensorDataOut_vec2;
  }
  // @@protoc_insertion_point(field_mutable:protobuf.SensorDataOut.leadPos)
  return leadpos_;
}
inline void SensorDataOut::set_allocated_leadpos(::protobuf::SensorDataOut_vec2* leadpos) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete leadpos_;
  }
  if (leadpos) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      leadpos = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, leadpos, submessage_arena);
    }
    
  } else {
    
  }
  leadpos_ = leadpos;
  // @@protoc_insertion_point(field_set_allocated:protobuf.SensorDataOut.leadPos)
}

// .protobuf.SensorDataOut.vec2 ownPos = 4;
inline bool SensorDataOut::has_ownpos() const {
  return this != internal_default_instance() && ownpos_ != NULL;
}
inline void SensorDataOut::clear_ownpos() {
  if (GetArenaNoVirtual() == NULL && ownpos_ != NULL) {
    delete ownpos_;
  }
  ownpos_ = NULL;
}
inline const ::protobuf::SensorDataOut_vec2& SensorDataOut::ownpos() const {
  const ::protobuf::SensorDataOut_vec2* p = ownpos_;
  // @@protoc_insertion_point(field_get:protobuf.SensorDataOut.ownPos)
  return p != NULL ? *p : *reinterpret_cast<const ::protobuf::SensorDataOut_vec2*>(
      &::protobuf::_SensorDataOut_vec2_default_instance_);
}
inline ::protobuf::SensorDataOut_vec2* SensorDataOut::release_ownpos() {
  // @@protoc_insertion_point(field_release:protobuf.SensorDataOut.ownPos)
  
  ::protobuf::SensorDataOut_vec2* temp = ownpos_;
  ownpos_ = NULL;
  return temp;
}
inline ::protobuf::SensorDataOut_vec2* SensorDataOut::mutable_ownpos() {
  
  if (ownpos_ == NULL) {
    ownpos_ = new ::protobuf::SensorDataOut_vec2;
  }
  // @@protoc_insertion_point(field_mutable:protobuf.SensorDataOut.ownPos)
  return ownpos_;
}
inline void SensorDataOut::set_allocated_ownpos(::protobuf::SensorDataOut_vec2* ownpos) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete ownpos_;
  }
  if (ownpos) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      ownpos = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ownpos, submessage_arena);
    }
    
  } else {
    
  }
  ownpos_ = ownpos;
  // @@protoc_insertion_point(field_set_allocated:protobuf.SensorDataOut.ownPos)
}

// .protobuf.SensorDataOut.vec2 cornerFrontRight = 5;
inline bool SensorDataOut::has_cornerfrontright() const {
  return this != internal_default_instance() && cornerfrontright_ != NULL;
}
inline void SensorDataOut::clear_cornerfrontright() {
  if (GetArenaNoVirtual() == NULL && cornerfrontright_ != NULL) {
    delete cornerfrontright_;
  }
  cornerfrontright_ = NULL;
}
inline const ::protobuf::SensorDataOut_vec2& SensorDataOut::cornerfrontright() const {
  const ::protobuf::SensorDataOut_vec2* p = cornerfrontright_;
  // @@protoc_insertion_point(field_get:protobuf.SensorDataOut.cornerFrontRight)
  return p != NULL ? *p : *reinterpret_cast<const ::protobuf::SensorDataOut_vec2*>(
      &::protobuf::_SensorDataOut_vec2_default_instance_);
}
inline ::protobuf::SensorDataOut_vec2* SensorDataOut::release_cornerfrontright() {
  // @@protoc_insertion_point(field_release:protobuf.SensorDataOut.cornerFrontRight)
  
  ::protobuf::SensorDataOut_vec2* temp = cornerfrontright_;
  cornerfrontright_ = NULL;
  return temp;
}
inline ::protobuf::SensorDataOut_vec2* SensorDataOut::mutable_cornerfrontright() {
  
  if (cornerfrontright_ == NULL) {
    cornerfrontright_ = new ::protobuf::SensorDataOut_vec2;
  }
  // @@protoc_insertion_point(field_mutable:protobuf.SensorDataOut.cornerFrontRight)
  return cornerfrontright_;
}
inline void SensorDataOut::set_allocated_cornerfrontright(::protobuf::SensorDataOut_vec2* cornerfrontright) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete cornerfrontright_;
  }
  if (cornerfrontright) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      cornerfrontright = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, cornerfrontright, submessage_arena);
    }
    
  } else {
    
  }
  cornerfrontright_ = cornerfrontright;
  // @@protoc_insertion_point(field_set_allocated:protobuf.SensorDataOut.cornerFrontRight)
}

// .protobuf.SensorDataOut.vec2 cornerFrontLeft = 6;
inline bool SensorDataOut::has_cornerfrontleft() const {
  return this != internal_default_instance() && cornerfrontleft_ != NULL;
}
inline void SensorDataOut::clear_cornerfrontleft() {
  if (GetArenaNoVirtual() == NULL && cornerfrontleft_ != NULL) {
    delete cornerfrontleft_;
  }
  cornerfrontleft_ = NULL;
}
inline const ::protobuf::SensorDataOut_vec2& SensorDataOut::cornerfrontleft() const {
  const ::protobuf::SensorDataOut_vec2* p = cornerfrontleft_;
  // @@protoc_insertion_point(field_get:protobuf.SensorDataOut.cornerFrontLeft)
  return p != NULL ? *p : *reinterpret_cast<const ::protobuf::SensorDataOut_vec2*>(
      &::protobuf::_SensorDataOut_vec2_default_instance_);
}
inline ::protobuf::SensorDataOut_vec2* SensorDataOut::release_cornerfrontleft() {
  // @@protoc_insertion_point(field_release:protobuf.SensorDataOut.cornerFrontLeft)
  
  ::protobuf::SensorDataOut_vec2* temp = cornerfrontleft_;
  cornerfrontleft_ = NULL;
  return temp;
}
inline ::protobuf::SensorDataOut_vec2* SensorDataOut::mutable_cornerfrontleft() {
  
  if (cornerfrontleft_ == NULL) {
    cornerfrontleft_ = new ::protobuf::SensorDataOut_vec2;
  }
  // @@protoc_insertion_point(field_mutable:protobuf.SensorDataOut.cornerFrontLeft)
  return cornerfrontleft_;
}
inline void SensorDataOut::set_allocated_cornerfrontleft(::protobuf::SensorDataOut_vec2* cornerfrontleft) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete cornerfrontleft_;
  }
  if (cornerfrontleft) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      cornerfrontleft = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, cornerfrontleft, submessage_arena);
    }
    
  } else {
    
  }
  cornerfrontleft_ = cornerfrontleft;
  // @@protoc_insertion_point(field_set_allocated:protobuf.SensorDataOut.cornerFrontLeft)
}

// .protobuf.SensorDataOut.vec2 cornerRearRight = 7;
inline bool SensorDataOut::has_cornerrearright() const {
  return this != internal_default_instance() && cornerrearright_ != NULL;
}
inline void SensorDataOut::clear_cornerrearright() {
  if (GetArenaNoVirtual() == NULL && cornerrearright_ != NULL) {
    delete cornerrearright_;
  }
  cornerrearright_ = NULL;
}
inline const ::protobuf::SensorDataOut_vec2& SensorDataOut::cornerrearright() const {
  const ::protobuf::SensorDataOut_vec2* p = cornerrearright_;
  // @@protoc_insertion_point(field_get:protobuf.SensorDataOut.cornerRearRight)
  return p != NULL ? *p : *reinterpret_cast<const ::protobuf::SensorDataOut_vec2*>(
      &::protobuf::_SensorDataOut_vec2_default_instance_);
}
inline ::protobuf::SensorDataOut_vec2* SensorDataOut::release_cornerrearright() {
  // @@protoc_insertion_point(field_release:protobuf.SensorDataOut.cornerRearRight)
  
  ::protobuf::SensorDataOut_vec2* temp = cornerrearright_;
  cornerrearright_ = NULL;
  return temp;
}
inline ::protobuf::SensorDataOut_vec2* SensorDataOut::mutable_cornerrearright() {
  
  if (cornerrearright_ == NULL) {
    cornerrearright_ = new ::protobuf::SensorDataOut_vec2;
  }
  // @@protoc_insertion_point(field_mutable:protobuf.SensorDataOut.cornerRearRight)
  return cornerrearright_;
}
inline void SensorDataOut::set_allocated_cornerrearright(::protobuf::SensorDataOut_vec2* cornerrearright) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete cornerrearright_;
  }
  if (cornerrearright) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      cornerrearright = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, cornerrearright, submessage_arena);
    }
    
  } else {
    
  }
  cornerrearright_ = cornerrearright;
  // @@protoc_insertion_point(field_set_allocated:protobuf.SensorDataOut.cornerRearRight)
}

// .protobuf.SensorDataOut.vec2 cornerRearLeft = 8;
inline bool SensorDataOut::has_cornerrearleft() const {
  return this != internal_default_instance() && cornerrearleft_ != NULL;
}
inline void SensorDataOut::clear_cornerrearleft() {
  if (GetArenaNoVirtual() == NULL && cornerrearleft_ != NULL) {
    delete cornerrearleft_;
  }
  cornerrearleft_ = NULL;
}
inline const ::protobuf::SensorDataOut_vec2& SensorDataOut::cornerrearleft() const {
  const ::protobuf::SensorDataOut_vec2* p = cornerrearleft_;
  // @@protoc_insertion_point(field_get:protobuf.SensorDataOut.cornerRearLeft)
  return p != NULL ? *p : *reinterpret_cast<const ::protobuf::SensorDataOut_vec2*>(
      &::protobuf::_SensorDataOut_vec2_default_instance_);
}
inline ::protobuf::SensorDataOut_vec2* SensorDataOut::release_cornerrearleft() {
  // @@protoc_insertion_point(field_release:protobuf.SensorDataOut.cornerRearLeft)
  
  ::protobuf::SensorDataOut_vec2* temp = cornerrearleft_;
  cornerrearleft_ = NULL;
  return temp;
}
inline ::protobuf::SensorDataOut_vec2* SensorDataOut::mutable_cornerrearleft() {
  
  if (cornerrearleft_ == NULL) {
    cornerrearleft_ = new ::protobuf::SensorDataOut_vec2;
  }
  // @@protoc_insertion_point(field_mutable:protobuf.SensorDataOut.cornerRearLeft)
  return cornerrearleft_;
}
inline void SensorDataOut::set_allocated_cornerrearleft(::protobuf::SensorDataOut_vec2* cornerrearleft) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete cornerrearleft_;
  }
  if (cornerrearleft) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      cornerrearleft = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, cornerrearleft, submessage_arena);
    }
    
  } else {
    
  }
  cornerrearleft_ = cornerrearleft;
  // @@protoc_insertion_point(field_set_allocated:protobuf.SensorDataOut.cornerRearLeft)
}

// float leadSpeed = 9;
inline void SensorDataOut::clear_leadspeed() {
  leadspeed_ = 0;
}
inline float SensorDataOut::leadspeed() const {
  // @@protoc_insertion_point(field_get:protobuf.SensorDataOut.leadSpeed)
  return leadspeed_;
}
inline void SensorDataOut::set_leadspeed(float value) {
  
  leadspeed_ = value;
  // @@protoc_insertion_point(field_set:protobuf.SensorDataOut.leadSpeed)
}

// float ownSpeed = 10;
inline void SensorDataOut::clear_ownspeed() {
  ownspeed_ = 0;
}
inline float SensorDataOut::ownspeed() const {
  // @@protoc_insertion_point(field_get:protobuf.SensorDataOut.ownSpeed)
  return ownspeed_;
}
inline void SensorDataOut::set_ownspeed(float value) {
  
  ownspeed_ = value;
  // @@protoc_insertion_point(field_set:protobuf.SensorDataOut.ownSpeed)
}

// int32 curGear = 11;
inline void SensorDataOut::clear_curgear() {
  curgear_ = 0;
}
inline ::google::protobuf::int32 SensorDataOut::curgear() const {
  // @@protoc_insertion_point(field_get:protobuf.SensorDataOut.curGear)
  return curgear_;
}
inline void SensorDataOut::set_curgear(::google::protobuf::int32 value) {
  
  curgear_ = value;
  // @@protoc_insertion_point(field_set:protobuf.SensorDataOut.curGear)
}

// float steerLock = 12;
inline void SensorDataOut::clear_steerlock() {
  steerlock_ = 0;
}
inline float SensorDataOut::steerlock() const {
  // @@protoc_insertion_point(field_get:protobuf.SensorDataOut.steerLock)
  return steerlock_;
}
inline void SensorDataOut::set_steerlock(float value) {
  
  steerlock_ = value;
  // @@protoc_insertion_point(field_set:protobuf.SensorDataOut.steerLock)
}

// float enginerpm = 13;
inline void SensorDataOut::clear_enginerpm() {
  enginerpm_ = 0;
}
inline float SensorDataOut::enginerpm() const {
  // @@protoc_insertion_point(field_get:protobuf.SensorDataOut.enginerpm)
  return enginerpm_;
}
inline void SensorDataOut::set_enginerpm(float value) {
  
  enginerpm_ = value;
  // @@protoc_insertion_point(field_set:protobuf.SensorDataOut.enginerpm)
}

// float enginerpmMax = 14;
inline void SensorDataOut::clear_enginerpmmax() {
  enginerpmmax_ = 0;
}
inline float SensorDataOut::enginerpmmax() const {
  // @@protoc_insertion_point(field_get:protobuf.SensorDataOut.enginerpmMax)
  return enginerpmmax_;
}
inline void SensorDataOut::set_enginerpmmax(float value) {
  
  enginerpmmax_ = value;
  // @@protoc_insertion_point(field_set:protobuf.SensorDataOut.enginerpmMax)
}

// float steer = 15;
inline void SensorDataOut::clear_steer() {
  steer_ = 0;
}
inline float SensorDataOut::steer() const {
  // @@protoc_insertion_point(field_get:protobuf.SensorDataOut.steer)
  return steer_;
}
inline void SensorDataOut::set_steer(float value) {
  
  steer_ = value;
  // @@protoc_insertion_point(field_set:protobuf.SensorDataOut.steer)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protobuf

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_SensorDataOut_2eproto__INCLUDED
